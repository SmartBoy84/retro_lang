use std::{env, fs, io::Write, path::Path};

const MAP_FILE: &str = "retro.map";
const FILE_NAME: &str = "inst_set.rs";

const HEADER: &str = "/// Auto-generated by build.rs\n";

const INST_ARRAY_NAME: &str = "INST_NAMES";
const OP_ARRAY_NAME: &str = "OP_CODES";

fn push_str_array(s: &str, array_str: &mut String) {
    array_str.push('"');
    array_str.push_str(s.trim());
    array_str.push('"');
    array_str.push(',');
}

fn initialise_str_array(name: &str) -> String {
    let mut s = String::new();
    s.push_str("pub const ");
    s.push_str(name);
    s.push_str(": &[&str] = &[");
    s
}

fn main() {
    let f = fs::read_to_string(MAP_FILE).unwrap();

    let mut inst_array_str = initialise_str_array(INST_ARRAY_NAME);
    let mut op_array_str = initialise_str_array(OP_ARRAY_NAME);

    for l in f.lines() {
        let mut s = l.trim().split_ascii_whitespace();
        let Some(inst) = s.next() else {
            continue; // empty inst - new line?
        };
        let Some(op_code) = s.next() else {
            panic!("bad inst - no op code");
        };
        push_str_array(inst, &mut inst_array_str);
        push_str_array(op_code, &mut op_array_str);
    }
    inst_array_str.push_str("];");
    op_array_str.push_str("];");

    let mut f = fs::OpenOptions::new()
        .write(true)
        .truncate(true)
        .create(true)
        .open(Path::new(&env::var("OUT_DIR").expect("OUT_DIR undefined")).join(FILE_NAME))
        .unwrap();

    f.write_all(HEADER.as_bytes()).unwrap();
    f.write_all(inst_array_str.as_bytes()).unwrap();
    f.write_all(op_array_str.as_bytes()).unwrap();
}
